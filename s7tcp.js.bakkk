// logger
const pino = require('pino');
const logger = pino({ prettyPrint: true });

// node libs
const events = require('events');
const net = require('net');

// custom libs
const s7comm = require("./s7comm");

class s7tcp {
    
    //#region ctors

    constructor(ip, port, rack, slot, autoreconnect = 0, timeout = 0) {  
        this.ip = ip;
        this.port = port;
        this.slot = slot;
        this.rack = rack;
        this.autoreconnect = autoreconnect;
        this.timeout = timeout;

        this._alreadyConnected = false;
        this._autoriconnect();
    }

    //#endregion

    //#region methods

    async init() {
        this.socket = new net.Socket();
        this.socket.setTimeout(this.timeout);
        this.socket.setKeepAlive(true, this.timeout);

        // managed events
        this.socket.on('connect', () => this.onConnect(this));
        this.socket.on('close', hadError => this.onClose(this, hadError));  
        this.socket.on('end', () => this.onEnd(this));
        this.socket.on('ready', () => this.onReady(this));
        this.socket.on('timeout', () => this.onTimeout(this));
        this.socket.on('error', err => this.onError(this, err));  

        logger.info("Try to connect..");
        let connRes = await this._connect();
        let regSessRes = await this._registerSession();
        let negPDURes = await this._negotiatePDU();
        return connRes && regSessRes && negPDURes;
    }

    dispose() {   
        this.socket.end();        
        this.socket.destroy(new Error('dispose'));
    }

    _autoriconnect() {
        if (this.autoreconnect) {     
            if (this._alreadyConnected) {
                setTimeout(() => {            
                    this.init();
                }, this.autoreconnect);
            } else {
                this.init();
                this._alreadyConnected = true;
            }                   
        } 
    }

    //#endregion

    //#region Promises

    _connect() 
    {
        let self = this;
        return new Promise(function (resolve, reject) {
            self.socket.connect(self.port, self.ip, () => {
                resolve(true);
            });
        });
    }
    
    _registerSession()
    {
        let self = this;
        return new Promise((resolve, reject) => {
            let request = Uint8Array.from(s7comm.RegisterSessionRequest(self.rack, self.slot));
            let result = self.socket.write(request, (e) => {
                if (e) {
                    throw e;
                };
                let getResponse = (buffer) => {
                    self.socket.off("data", getResponse);
                    let response = Uint8Array.from(buffer);
                    if (response.length != 22)
                    {
                        let e = new Error("Error registering session!"); 
                        throw e;
                    } 
                    resolve(true);
                };
                self.socket.once("data", buffer => getResponse(buffer));
            })
        });
    }

    _negotiatePDU()
    {
        let self = this;
        return new Promise((resolve, reject) => {
            let request = Uint8Array.from(s7comm.NegotiatePDULengthRequest());
            let result = self.socket.write(request, (e) => {
                if (e) {
                    throw e;
                };
                let getResponse = (buffer) => {
                    self.socket.off("data", getResponse);
                    let response = Uint8Array.from(buffer);
                    if (response.length != 27)
                    {
                        let e = new Error("Error negotiating PDU!");
                        throw e;
                    }                 
                    resolve(true);
                };
                self.socket.once("data", buffer => getResponse(buffer));
            })
        });        
    }

    //#endregion 

    //#region events

    async onConnect(event) {
        logger.info("Connected!");        
    }

    onClose(event, hadError) {
        logger.info("Close " + (hadError ? "with" : "without") + " errors!");
        this._autoriconnect();
    }

    onEnd(event) {
        logger.info("Ended!");
    }

    onReady(event) {
        logger.info("Ready!");
    }

    onTimeout(event) {
        logger.info("Timeout!");
        this.dispose();
    }

    onError(event, err) {
        logger.info("Errors: " + err.message);
        this.dispose();
    }

    //#endregion

}

// TEST PURPOSE
var plc = new s7tcp("192.168.1.91", 102, 0, 1, 10000, 60000);